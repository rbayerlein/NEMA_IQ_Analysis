function [ave_circ, sd_circ, max_circ, weights] = roi_circ_sub_2D (data, xctr, yctr, diam, wflg)%[ave_circ,sd_circ] = voi_sph_sub(data, xctr, yctr, zctr, diam, wflg)%     Circular ROI at (xctr,yctr) with diameter diam (pixels)%     if wflg==1:  contribution of each pixel is weighted by sq. of ROI%     area within pixel% (MeDW 06/22/10)% Note: xctr and yctr are pixel indeces,%       i.e., xctr=3.0 is center of the 3rd voxel;%             xctr=2.5 is boundary btw. voxels 2 and 3nsub=10;    % Number of subsamples on each side of a voxelnsubstep=1.0/nsub;nsubhalf=nsubstep/2.0;% Find indexes of voxels containing (portion of) ROIrad=(diam)/2.0; radsq=rad^2;epsrad=0.01;  rade=rad-epsrad;  % to avoid expantion of region if ROI touches boundaryxmin=round(xctr-rade);  xmax=round(xctr+rade);ymin=round(yctr-rade);  ymax=round(yctr+rade);roivoxels=(xmax-xmin+1)*(ymax-ymin+1);wt=zeros(roivoxels,1);sph=zeros(roivoxels,1);if xmin<0    xmin=1;endif xmax>size(data,1)    xmax=size(data,1);endif ymin<0    ymin=1;endif ymax>size(data,2)    ymax=size(data,2);end% Compute counts inside VOIind=0;for iy=ymin:ymax    for ix=xmin:xmax        ind=ind+1;        sph(ind)=data(ix,iy);        iy1=iy-0.5+nsubhalf-yctr;        iy2=iy+0.5-yctr;        ix1=ix-0.5+nsubhalf-xctr;        ix2=ix+0.5-xctr;        for ysub= iy1 : nsubstep : iy2            ysq=(ysub)^2;            for xsub= ix1 : nsubstep : ix2                rsub= (xsub)^2 + ysq;                if (rsub<=radsq),  wt(ind)=wt(ind)+1; end            end        end    endendif (wflg==1) wt=wt.*wt; end   % weights take into account area of ROI in each voxelave_circ=(sum(sph.*wt)/sum(wt))'; %sd_circ=(sqrt(var(sph,wt)))';     %max_circ=max(sph)';weights=sqrt(sum(wt.^2))/sum(wt);